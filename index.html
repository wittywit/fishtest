<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organic Fish Swimming - Glasscape Kiosk</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #ffffff;
            font-family: Arial, sans-serif;
            cursor: none;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: black;
            font-size: 18px;
            z-index: 100;
        }
        #performance {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(0,0,0,0.7);
            font-size: 12px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading fish models...</div>
        <div id="performance">
            FPS: <span id="fps">0</span><br>
            Fish Count: <span id="fishCount">0</span><br>
            Memory: <span id="memory">0MB</span>
        </div>
    </div>

    <!-- Three.js CDN - using working CDN links -->
    <script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Performance optimized fish swimming app for 1GB RAM
        class OptimizedFishSwimming {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.fishes = [];
                this.fishModel = null;
                this.mixer = null;
                this.clock = new THREE.Clock();
                this.spawnedFish = 0;
                this.lastSpawnTime = 0;
                
                // Performance settings for 1GB RAM
                this.maxFish = Math.floor(Math.random() * 4) + 2; // Random 2-5 fish
                this.renderDistance = 50;
                this.lodLevels = 2;
                this.fishVisible = 0;
                
                // Interaction settings
                this.mouseX = 0;
                this.mouseY = 0;
                this.attractionPoint = new THREE.Vector3();
                
                // Performance monitoring
                this.frameCount = 0;
                this.lastTime = performance.now();
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupLights();
                this.loadFishModel();
                this.setupInteraction();
                this.animate();
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = null; // No fog for white background

                // Camera - Front view like looking through aquarium glass
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 20); // In front, looking at fish
                this.camera.lookAt(0, 0, 0); // Look at center of aquarium

                // Optimized renderer settings for ARM
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false, // Disable for performance
                    powerPreference: "low-power",
                    precision: "mediump"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
                this.renderer.shadowMap.enabled = false; // Disable shadows for performance
                this.renderer.setClearColor(0xffffff); // White background
                
                document.getElementById('container').appendChild(this.renderer.domElement);

                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize(), false);
            }

            setupLights() {
                // Bright lighting for front view
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);

                // Light from front like room lighting
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(10, 10, 5); // From front-right-above
                this.scene.add(directionalLight);
            }

            loadFishModel() {
                const loader = new THREE.GLTFLoader();
                
                // Try to load koi fish model
                const fishPaths = [
                    'koi_fish.glb',
                    '/home/uploads/koi_fish.glb',
                    '/home/uploads/video/koi_fish.glb'
                ];

                this.tryLoadFish(loader, fishPaths, 0);
            }

            tryLoadFish(loader, paths, index) {
                if (index >= paths.length) {
                    this.createPlaceholderFish();
                    return;
                }

                loader.load(
                    paths[index],
                    (gltf) => {
                        console.log('Fish model loaded successfully');
                        console.log('GLB contains', gltf.animations.length, 'animations');
                        gltf.animations.forEach((animation, i) => {
                            console.log(`Animation ${i}:`, animation.name, 'Duration:', animation.duration);
                        });
                        
                        this.fishModel = gltf.scene;
                        this.gltfAnimations = gltf.animations; // Store animations
                        this.optimizeModel(this.fishModel);
                        
                        this.createFishSchool();
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('performance').style.display = 'block';
                    },
                    (progress) => {
                        console.log('Loading progress:', progress);
                    },
                    (error) => {
                        console.log('Failed to load:', paths[index], error);
                        this.tryLoadFish(loader, paths, index + 1);
                    }
                );
            }

            optimizeModel(model) {
                // Optimize materials and geometry for performance
                model.traverse((child) => {
                    if (child.isMesh) {
                        // Reduce geometry complexity if needed
                        if (child.geometry.attributes.position.count > 1000) {
                            // Simplify high-poly models
                            child.geometry = child.geometry.clone();
                        }
                        
                        // Optimize materials
                        if (child.material) {
                            child.material.transparent = false;
                            child.material.alphaTest = 0;
                        }
                    }
                });
            }

            createPlaceholderFish() {
                console.log('Creating placeholder fish');
                // Fish-shaped geometry for top-down view - like a fish silhouette
                const geometry = new THREE.CylinderGeometry(0.5, 1.5, 4.0, 8);
                const material = new THREE.MeshLambertMaterial({ color: 0xff4444 }); // Bright red for visibility
                this.fishModel = new THREE.Mesh(geometry, material);
                
                this.createFishSchool();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('performance').style.display = 'block';
            }

            createFishSchool() {
                // Don't spawn all fish at once - they'll be spawned gradually in animate loop
                document.getElementById('fishCount').textContent = '0/' + this.maxFish;
                console.log('Fish school initialized - will spawn', this.maxFish, 'fish gradually');
            }

            createFish() {
                const fishMesh = this.fishModel.clone();
                
                const fish = {
                    mesh: fishMesh,
                    mixer: null,
                    velocity: new THREE.Vector3(
                        (Math.random() > 0.5 ? 1 : -1) * (0.01 + Math.random() * 0.01), // Left or right
                        (Math.random() - 0.5) * 0.005, // Minimal vertical movement
                        0 // No depth movement towards screen
                    ),
                    position: new THREE.Vector3(
                        (Math.random() > 0.5 ? -20 : 20), // Start at safe spawn position
                        (Math.random() - 0.5) * 6, // Different heights
                        (Math.random() - 0.5) * 20 // Much larger depth separation to prevent overlap
                    ),
                    targetVelocity: new THREE.Vector3(),
                    wanderAngle: Math.random() * Math.PI * 2,
                    speed: 0.008 + Math.random() * 0.012,
                    direction: Math.random() > 0.5 ? 1 : -1, // Swimming direction
                    phaseOffset: Math.random() * Math.PI * 2, // Random phase for motion variation
                    swayAmplitude: 0.3 + Math.random() * 0.7, // Random sway intensity
                    swaySpeed: 0.5 + Math.random() * 1.5 // Random sway speed
                };

                // Setup individual animation mixer for each fish
                if (this.gltfAnimations && this.gltfAnimations.length > 0) {
                    fish.mixer = new THREE.AnimationMixer(fishMesh);
                    const action = fish.mixer.clipAction(this.gltfAnimations[0]);
                    action.setLoop(THREE.LoopRepeat);
                    action.play();
                    console.log('Animation started for fish:', this.gltfAnimations[0].name);
                } else {
                    console.log('No animations found in GLB file');
                }

                fish.mesh.position.copy(fish.position);
                
                // Size based on depth - closer fish (positive Z) are bigger, distant fish (negative Z) are smaller
                const baseSize = 2.0;
                const depthScale = 1.0 + (fish.position.z / 20.0); // Scale factor based on Z position (adjusted for larger depth range)
                const finalScale = Math.max(0.3, Math.min(5.0, baseSize * depthScale)); // Wider scale range for better depth perception
                
                fish.mesh.scale.set(finalScale, finalScale, finalScale);
                
                // Orient fish for front view - they should face their swimming direction
                if (fish.direction === -1) {
                    // Swimming left - face left
                    fish.mesh.rotation.y = Math.PI; // 180 degrees - face left
                } else {
                    // Swimming right - face right (default orientation)
                    fish.mesh.rotation.y = 0; // 0 degrees - face right
                }
                
                console.log('Fish at Z:', fish.position.z.toFixed(1), 'Scale:', finalScale.toFixed(1), 'Direction:', fish.direction);
                console.log('Fish created at:', fish.position);
                
                return fish;
            }

            setupInteraction() {
                // Touch and mouse interaction
                const handleInteraction = (event) => {
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const clientX = event.clientX || (event.touches && event.touches[0].clientX) || 0;
                    const clientY = event.clientY || (event.touches && event.touches[0].clientY) || 0;
                    
                    this.mouseX = ((clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouseY = -((clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // Convert to world coordinates
                    this.attractionPoint.set(
                        this.mouseX * 15,
                        this.mouseY * 10,
                        0
                    );
                };

                document.addEventListener('mousemove', handleInteraction);
                document.addEventListener('touchmove', handleInteraction, { passive: true });
                document.addEventListener('touchstart', handleInteraction, { passive: true });
            }

            updateFish(fish, deltaTime) {
                // Always use consistent horizontal movement
                fish.velocity.set(fish.direction * 0.03, 0, 0);
                
                // Only add behavioral forces in center area
                if (Math.abs(fish.position.x) < 10) {
                    const separation = this.separate(fish);
                    const wander = this.wander(fish);
                    
                    // Add subtle behavioral forces
                    fish.velocity.add(separation.multiplyScalar(0.5));
                    fish.velocity.add(wander.multiplyScalar(0.1));
                    
                    // Add swimming sway
                    const time = this.clock.getElapsedTime();
                    const swayY = Math.sin(time * fish.swaySpeed + fish.phaseOffset) * fish.swayAmplitude * 0.005;
                    fish.velocity.add(new THREE.Vector3(0, swayY, 0));
                }

                // Update position
                fish.position.add(fish.velocity);

                // Wrap around screen bounds
                this.wrapAround(fish);

                // Update mesh position
                fish.mesh.position.copy(fish.position);
                
                // Debug position
                if (Math.abs(fish.position.x) > 20) {
                    console.log('Fish at edge position:', fish.position.x, 'velocity:', fish.velocity.x);
                }
            }

            separate(fish) {
                const desiredSeparation = 8.0;
                const steer = new THREE.Vector3();
                let count = 0;

                this.fishes.forEach(other => {
                    const d = fish.position.distanceTo(other.position);
                    if (d > 0 && d < desiredSeparation) {
                        const diff = fish.position.clone().sub(other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                });

                if (count > 0) {
                    steer.divideScalar(count);
                    steer.normalize();
                    steer.multiplyScalar(0.01);
                }

                return steer;
            }

            align(fish) {
                const neighborDist = 3.0;
                const sum = new THREE.Vector3();
                let count = 0;

                this.fishes.forEach(other => {
                    const d = fish.position.distanceTo(other.position);
                    if (d > 0 && d < neighborDist) {
                        sum.add(other.velocity);
                        count++;
                    }
                });

                if (count > 0) {
                    sum.divideScalar(count);
                    sum.normalize();
                    sum.multiplyScalar(0.02);
                }

                return sum;
            }

            cohesion(fish) {
                const neighborDist = 3.0;
                const sum = new THREE.Vector3();
                let count = 0;

                this.fishes.forEach(other => {
                    const d = fish.position.distanceTo(other.position);
                    if (d > 0 && d < neighborDist) {
                        sum.add(other.position);
                        count++;
                    }
                });

                if (count > 0) {
                    sum.divideScalar(count);
                    const steer = sum.sub(fish.position);
                    steer.normalize();
                    steer.multiplyScalar(0.01);
                    return steer;
                }

                return new THREE.Vector3();
            }

            attract(fish) {
                const steer = this.attractionPoint.clone().sub(fish.position);
                const d = steer.length();
                if (d > 0) {
                    steer.normalize();
                    steer.multiplyScalar(0.01 / Math.max(d * 0.1, 1));
                }
                return steer;
            }

            wander(fish) {
                fish.wanderAngle += (Math.random() - 0.5) * 0.1;
                const wander = new THREE.Vector3(
                    Math.cos(fish.wanderAngle) * 0.01,
                    Math.sin(fish.wanderAngle) * 0.01,
                    (Math.random() - 0.5) * 0.005
                );
                return wander;
            }

            wrapAround(fish) {
                // Fixed wrap boundaries - spawn within safe zone
                if (fish.position.x > 25) {
                    fish.position.x = -20; // Spawn on visible left side
                    fish.position.y = (Math.random() - 0.5) * 8;
                    fish.position.z = (Math.random() - 0.5) * 20;
                    this.updateFishScale(fish);
                    console.log('Fish wrapped right to left, teleported to:', fish.position.x);
                }
                if (fish.position.x < -25) {
                    fish.position.x = 20; // Spawn on visible right side  
                    fish.position.y = (Math.random() - 0.5) * 8;
                    fish.position.z = (Math.random() - 0.5) * 20;
                    this.updateFishScale(fish);
                    console.log('Fish wrapped left to right, teleported to:', fish.position.x);
                }
                
                // Keep fish within vertical bounds
                if (fish.position.y > 6) fish.position.y = 6;
                if (fish.position.y < -6) fish.position.y = -6;
                
                // Keep fish within expanded depth bounds for proper separation
                if (fish.position.z > 12) fish.position.z = 12;
                if (fish.position.z < -12) fish.position.z = -12;
            }

            updateFishScale(fish) {
                // Update fish size based on depth position (adjusted for larger depth range)
                const baseSize = 2.0;
                const depthScale = 1.0 + (fish.position.z / 20.0);
                const finalScale = Math.max(0.3, Math.min(5.0, baseSize * depthScale));
                fish.mesh.scale.set(finalScale, finalScale, finalScale);
            }

            updatePerformance() {
                this.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    document.getElementById('fps').textContent = fps;
                    
                    // Memory usage (approximate)
                    const memory = Math.round(performance.memory ? 
                        performance.memory.usedJSHeapSize / 1024 / 1024 : 0);
                    document.getElementById('memory').textContent = memory;
                    
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const deltaTime = this.clock.getDelta();
                const currentTime = this.clock.getElapsedTime();

                // Gradual fish spawning - spawn one fish every 3-6 seconds
                if (this.spawnedFish < this.maxFish && currentTime - this.lastSpawnTime > (3 + Math.random() * 3)) {
                    const fish = this.createFish();
                    this.fishes.push(fish);
                    this.scene.add(fish.mesh);
                    this.spawnedFish++;
                    this.lastSpawnTime = currentTime;
                    
                    document.getElementById('fishCount').textContent = this.spawnedFish + '/' + this.maxFish;
                    console.log('Fish', this.spawnedFish, 'spawned at time:', currentTime.toFixed(1));
                }

                // Update each fish and their individual animations
                this.fishes.forEach(fish => {
                    // Update individual fish animation
                    if (fish.mixer) {
                        fish.mixer.update(deltaTime);
                    }
                    this.updateFish(fish, deltaTime);
                });

                // Render
                this.renderer.render(this.scene, this.camera);

                // Update performance monitor
                this.updatePerformance();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialize the app when page loads and Three.js is ready
        function initApp() {
            if (typeof THREE !== 'undefined' && THREE.GLTFLoader) {
                new OptimizedFishSwimming();
            } else {
                setTimeout(initApp, 100);
            }
        }
        
        window.addEventListener('load', initApp);

        // Clean up on unload
        window.addEventListener('beforeunload', () => {
            // Clean up Three.js resources
            if (window.fishApp && window.fishApp.renderer) {
                window.fishApp.renderer.dispose();
            }
        });
    </script>
</body>
</html>