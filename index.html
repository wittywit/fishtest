<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organic Fish Swimming - Glasscape Kiosk</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #ffffff;
            font-family: Arial, sans-serif;
            cursor: none;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: black;
            font-size: 18px;
            z-index: 100;
        }
        #performance {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(0,0,0,0.7);
            font-size: 12px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">Loading fish models...</div>
        <div id="performance">
            FPS: <span id="fps">0</span><br>
            Fish Count: <span id="fishCount">0</span><br>
            Memory: <span id="memory">0MB</span>
        </div>
    </div>

    <!-- Three.js CDN - using working CDN links -->
    <script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Performance optimized fish swimming app for 1GB RAM
        class OptimizedFishSwimming {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.fishes = [];
                this.fishModel = null;
                this.mixer = null;
                this.clock = new THREE.Clock();
                this.spawnedFish = 0;
                this.lastSpawnTime = 0;
                
                // Performance settings for 1GB RAM
                this.maxFish = Math.floor(Math.random() * 4) + 2; // Random 2-5 fish
                this.renderDistance = 50;
                this.lodLevels = 2;
                this.fishVisible = 0;
                
                // Interaction settings
                this.mouseX = 0;
                this.mouseY = 0;
                this.attractionPoint = new THREE.Vector3();
                this.clickPosition = new THREE.Vector3();
                this.scareEffect = false;
                this.scareRadius = 8;
                this.lastClickTime = 0;
                this.clickDelay = 300; // Double-click detection window (ms)
                
                // Performance monitoring
                this.frameCount = 0;
                this.lastTime = performance.now();
                
                this.init();
            }

            init() {
                this.setupScene();
                this.setupLights();
                this.loadFishModel();
                this.setupInteraction();
                this.animate();
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = null; // No fog for white background

                // Camera - Top-down view 
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 15, 0); // Above aquarium, looking down
                this.camera.lookAt(0, 0, 0); // Look down at center of aquarium

                // Optimized renderer settings for ARM
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false, // Disable for performance
                    powerPreference: "low-power",
                    precision: "mediump"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
                this.renderer.shadowMap.enabled = false; // Disable shadows for performance
                this.renderer.setClearColor(0xffffff); // White background
                
                document.getElementById('container').appendChild(this.renderer.domElement);

                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize(), false);
            }

            setupLights() {
                // Bright lighting for top-down aquarium view (matching test page)
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);

                // Light from above like aquarium lighting
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(10, 10, 5); // From front-right-above (like test page)
                this.scene.add(directionalLight);
            }

            loadFishModel() {
                const loader = new THREE.GLTFLoader();
                
                // Try to load koi fish model
                const fishPaths = [
                    'koi_fish.glb',
                    '/home/uploads/koi_fish.glb',
                    '/home/uploads/video/koi_fish.glb'
                ];

                this.tryLoadFish(loader, fishPaths, 0);
            }

            tryLoadFish(loader, paths, index) {
                if (index >= paths.length) {
                    this.createPlaceholderFish();
                    return;
                }

                loader.load(
                    paths[index],
                    (gltf) => {
                        console.log('Fish model loaded successfully');
                        console.log('GLB contains', gltf.animations.length, 'animations');
                        gltf.animations.forEach((animation, i) => {
                            console.log(`Animation ${i}:`, animation.name, 'Duration:', animation.duration);
                        });
                        
                        this.fishModel = gltf.scene;
                        this.gltfAnimations = gltf.animations; // Store animations
                        this.optimizeModel(this.fishModel);
                        
                        this.createFishSchool();
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('performance').style.display = 'block';
                    },
                    (progress) => {
                        console.log('Loading progress:', progress);
                    },
                    (error) => {
                        console.log('Failed to load:', paths[index], error);
                        this.tryLoadFish(loader, paths, index + 1);
                    }
                );
            }

            optimizeModel(model) {
                // Optimize materials and geometry for performance
                model.traverse((child) => {
                    if (child.isMesh) {
                        // Reduce geometry complexity if needed
                        if (child.geometry.attributes.position.count > 1000) {
                            // Simplify high-poly models
                            child.geometry = child.geometry.clone();
                        }
                        
                        // Optimize materials
                        if (child.material) {
                            child.material.transparent = false;
                            child.material.alphaTest = 0;
                        }
                    }
                });
            }

            createPlaceholderFish() {
                console.log('Creating placeholder fish');
                // Fish-shaped geometry for top-down view - like a fish silhouette
                const geometry = new THREE.CylinderGeometry(0.5, 1.5, 4.0, 8);
                const material = new THREE.MeshLambertMaterial({ color: 0xff4444 }); // Bright red for visibility
                this.fishModel = new THREE.Mesh(geometry, material);
                
                this.createFishSchool();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('performance').style.display = 'block';
            }

            createFishSchool() {
                // Don't spawn all fish at once - they'll be spawned gradually in animate loop
                document.getElementById('fishCount').textContent = '0/' + this.maxFish;
                console.log('Fish school initialized - will spawn', this.maxFish, 'fish gradually');
            }

            createFish() {
                const fishMesh = this.fishModel.clone();
                
                const fish = {
                    mesh: fishMesh,
                    mixer: null,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.04, // Random X movement
                        0, // Y is vertical (up/down from camera)
                        (Math.random() - 0.5) * 0.04  // Random Z movement (depth in aquarium)
                    ),
                    position: new THREE.Vector3(
                        (Math.random() - 0.5) * 20, // Random X position across aquarium
                        0, // Fish swim at water surface level (Y=0)
                        (Math.random() - 0.5) * 15  // Random Z position in aquarium depth
                    ),
                    targetVelocity: new THREE.Vector3(),
                    wanderAngle: Math.random() * Math.PI * 2,
                    speed: 0.015 + Math.random() * 0.02,
                    direction: Math.random() > 0.5 ? 1 : -1, // Swimming direction
                    phaseOffset: Math.random() * Math.PI * 2, // Random phase for motion variation
                    swayAmplitude: 0.3 + Math.random() * 0.7, // Random sway intensity
                    swaySpeed: 0.5 + Math.random() * 1.5, // Random sway speed
                    
                    // Natural fish swimming parameters
                    bodyWavePhase: Math.random() * Math.PI * 2, // Body undulation phase
                    tailBeatFreq: 2 + Math.random() * 2, // Tail beating frequency
                    swimming: {
                        forward: new THREE.Vector3(
                            Math.cos(Math.random() * Math.PI * 2), 
                            0, 
                            Math.sin(Math.random() * Math.PI * 2)
                        ).normalize(), // Random initial direction
                        path: [], // Swimming path history
                        turning: false,
                        turnStartTime: 0,
                        targetAngle: 0, // Target angle for turning
                        cruiseSpeed: 0.025 + Math.random() * 0.015,
                        burstSpeed: 0.08 + Math.random() * 0.04
                    }
                };

                // Setup individual animation mixer for each fish
                if (this.gltfAnimations && this.gltfAnimations.length > 0) {
                    fish.mixer = new THREE.AnimationMixer(fishMesh);
                    const action = fish.mixer.clipAction(this.gltfAnimations[0]);
                    action.setLoop(THREE.LoopRepeat);
                    action.play();
                    console.log('Animation started for fish:', this.gltfAnimations[0].name);
                } else {
                    console.log('No animations found in GLB file');
                }

                fish.mesh.position.copy(fish.position);
                
                // Size based on depth - closer fish (positive Z) are bigger, distant fish (negative Z) are smaller
                const baseSize = 1.0; // Reduced from 2.0 to make fish smaller
                const depthScale = 1.0 + (fish.position.z / 20.0); // Scale factor based on Z position
                const finalScale = Math.max(0.2, Math.min(1.5, baseSize * depthScale)); // Reduced max size from 5.0 to 1.5
                
                fish.mesh.scale.set(finalScale, finalScale, finalScale);
                
                // Orient fish for top-down view - adjust for sideways model
                const angle = Math.atan2(fish.velocity.z, fish.velocity.x);
                fish.mesh.rotation.y = angle - Math.PI / 2; // Subtract 90° to correct sideways orientation (try opposite)
                
                // Fish orientation: 0 degrees (no rotation)
                fish.mesh.rotation.x = 0; // 0 degrees - no X rotation
                
                console.log('Fish at Z:', fish.position.z.toFixed(1), 'Scale:', finalScale.toFixed(1), 'Direction:', fish.direction);
                console.log('Fish created at:', fish.position);
                
                return fish;
            }

            setupInteraction() {
                // Mouse/touch move interaction
                const handleMove = (event) => {
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const clientX = event.clientX || (event.touches && event.touches[0].clientX) || 0;
                    const clientY = event.clientY || (event.touches && event.touches[0].clientY) || 0;
                    
                    this.mouseX = ((clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouseY = -((clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // Convert to world coordinates
                    this.attractionPoint.set(
                        this.mouseX * 15,
                        this.mouseY * 10,
                        0
                    );
                };

                // Click interactions
                const handleClick = (event) => {
                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const clientX = event.clientX || (event.touches && event.touches[0].clientX) || 0;
                    const clientY = event.clientY || (event.touches && event.touches[0].clientY) || 0;
                    
                    const mouseX = ((clientX - rect.left) / rect.width) * 2 - 1;
                    const mouseY = -((clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // Convert click to world coordinates
                    this.clickPosition.set(
                        mouseX * 15,
                        mouseY * 10,
                        0
                    );
                    
                    const currentTime = Date.now();
                    const timeSinceLastClick = currentTime - this.lastClickTime;
                    
                    if (timeSinceLastClick < this.clickDelay) {
                        // Double click - change fish directions
                        this.handleDoubleClick();
                        console.log('Double click - fish changing direction');
                    } else {
                        // Single click - scare fish
                        this.handleSingleClick();
                        console.log('Single click - scaring fish at:', this.clickPosition);
                    }
                    
                    this.lastClickTime = currentTime;
                };

                document.addEventListener('mousemove', handleMove);
                document.addEventListener('touchmove', handleMove, { passive: true });
                document.addEventListener('click', handleClick);
                document.addEventListener('touchstart', handleClick, { passive: true });
            }

            handleSingleClick() {
                // Activate scare effect
                this.scareEffect = true;
                
                // Reset scare effect after 2 seconds
                setTimeout(() => {
                    this.scareEffect = false;
                }, 2000);
            }

            handleDoubleClick() {
                // Make all fish turn and swim in random new directions
                this.fishes.forEach(fish => {
                    // Give fish completely new random velocity direction
                    const angle = Math.random() * Math.PI * 2; // Random angle 0-360°
                    const speed = 0.02 + Math.random() * 0.02; // Random speed
                    
                    fish.velocity.set(
                        Math.cos(angle) * speed,
                        0,
                        Math.sin(angle) * speed
                    );
                    
                    console.log('Fish changed to new direction:', Math.round(angle * 180 / Math.PI) + '°');
                });
            }

            getScareFactor(fish) {
                if (!this.scareEffect) return new THREE.Vector3(0, 0, 0);
                
                // Calculate distance from click position
                const distance = fish.position.distanceTo(this.clickPosition);
                
                if (distance > this.scareRadius) return new THREE.Vector3(0, 0, 0);
                
                // Create flee vector (away from click)
                const fleeVector = fish.position.clone().sub(this.clickPosition);
                fleeVector.normalize();
                
                // Stronger effect for closer fish
                const intensity = (this.scareRadius - distance) / this.scareRadius;
                fleeVector.multiplyScalar(intensity * 0.1);
                
                return fleeVector;
            }

            updateFish(fish, deltaTime) {
                const time = this.clock.getElapsedTime();
                
                // Natural fish swimming behavior state machine
                this.updateFishBehavior(fish, time, deltaTime);
                
                // Calculate natural swimming forces
                const swimming = this.calculateSwimmingForces(fish, time);
                const separation = this.separate(fish);
                const scareForce = this.getScareFactor(fish);
                
                // Priority: Scare > Swimming > Separation
                if (scareForce.length() > 0) {
                    // Burst swimming when scared
                    fish.targetVelocity.copy(scareForce);
                    fish.swimming.turning = true;
                    fish.swimming.turnStartTime = time;
                } else {
                    // Normal swimming behavior
                    fish.targetVelocity.copy(swimming);
                    fish.targetVelocity.add(separation.multiplyScalar(0.3));
                }
                
                // Smooth velocity transition with realistic fish dynamics
                const lerpSpeed = fish.swimming.turning ? 0.15 : 0.08;
                fish.velocity.lerp(fish.targetVelocity, lerpSpeed);
                
                // Update position with undulating movement
                this.updateFishPosition(fish, time, deltaTime);
                
                // Keep fish in bounds
                this.keepInBounds(fish);
                
                // Update visual representation
                this.updateFishVisuals(fish, time);
            }

            updateFishBehavior(fish, time, deltaTime) {
                // Occasional direction changes
                if (!fish.swimming.turning && Math.random() < 0.001) {
                    fish.swimming.turning = true;
                    fish.swimming.turnStartTime = time;
                    
                    // Set target direction for gradual turning
                    const currentAngle = Math.atan2(fish.swimming.forward.z, fish.swimming.forward.x);
                    const angleChange = (Math.random() - 0.5) * Math.PI * 0.8; // Max 144° change
                    fish.swimming.targetAngle = currentAngle + angleChange;
                    
                    console.log('Fish starting turn by:', Math.round(angleChange * 180 / Math.PI) + '°');
                }
                
                // Gradual turning - fish turns its body slowly
                if (fish.swimming.turning) {
                    const currentAngle = Math.atan2(fish.swimming.forward.z, fish.swimming.forward.x);
                    const angleDiff = fish.swimming.targetAngle - currentAngle;
                    
                    // Normalize angle difference
                    let normalizedDiff = angleDiff;
                    while (normalizedDiff > Math.PI) normalizedDiff -= 2 * Math.PI;
                    while (normalizedDiff < -Math.PI) normalizedDiff += 2 * Math.PI;
                    
                    // Turn gradually
                    const turnRate = 1.5; // radians per second
                    const turnAmount = Math.sign(normalizedDiff) * Math.min(Math.abs(normalizedDiff), turnRate * deltaTime);
                    const newAngle = currentAngle + turnAmount;
                    
                    fish.swimming.forward.set(Math.cos(newAngle), 0, Math.sin(newAngle));
                    fish.swimming.forward.normalize();
                    
                    // Stop turning when close to target
                    if (Math.abs(normalizedDiff) < 0.1) {
                        fish.swimming.turning = false;
                        console.log('Fish completed turn');
                    }
                }
            }

            calculateSwimmingForces(fish, time) {
                // Fish ALWAYS moves forward in the direction it's facing
                // No sideways movement - only forward thrust
                const forwardForce = fish.swimming.forward.clone();
                const currentSpeed = fish.swimming.cruiseSpeed;
                forwardForce.multiplyScalar(currentSpeed);
                
                // Fish velocity = forward direction only (no wandering, no sideways)
                return forwardForce;
            }

            updateFishPosition(fish, time, deltaTime) {
                // Store path for realistic trailing behavior
                fish.swimming.path.push(fish.position.clone());
                if (fish.swimming.path.length > 10) {
                    fish.swimming.path.shift();
                }
                
                // Update position
                fish.position.add(fish.velocity);
            }

            updateFishVisuals(fish, time) {
                // Update mesh position
                fish.mesh.position.copy(fish.position);
                
                // Adjust for fish model's forward direction being sideways
                if (fish.velocity.length() > 0.001) {
                    const angle = Math.atan2(fish.velocity.z, fish.velocity.x);
                    fish.mesh.rotation.y = angle - Math.PI / 2; // Subtract 90° to correct sideways orientation (try opposite)
                    fish.mesh.rotation.x = 0; // Keep at 0 degrees
                    fish.mesh.rotation.z = 0; // No artificial sway - animation handles it
                }
            }

            separate(fish) {
                const desiredSeparation = 8.0;
                const steer = new THREE.Vector3();
                let count = 0;

                this.fishes.forEach(other => {
                    const d = fish.position.distanceTo(other.position);
                    if (d > 0 && d < desiredSeparation) {
                        const diff = fish.position.clone().sub(other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                });

                if (count > 0) {
                    steer.divideScalar(count);
                    steer.normalize();
                    steer.multiplyScalar(0.01);
                }

                return steer;
            }

            align(fish) {
                const neighborDist = 3.0;
                const sum = new THREE.Vector3();
                let count = 0;

                this.fishes.forEach(other => {
                    const d = fish.position.distanceTo(other.position);
                    if (d > 0 && d < neighborDist) {
                        sum.add(other.velocity);
                        count++;
                    }
                });

                if (count > 0) {
                    sum.divideScalar(count);
                    sum.normalize();
                    sum.multiplyScalar(0.02);
                }

                return sum;
            }

            cohesion(fish) {
                const neighborDist = 3.0;
                const sum = new THREE.Vector3();
                let count = 0;

                this.fishes.forEach(other => {
                    const d = fish.position.distanceTo(other.position);
                    if (d > 0 && d < neighborDist) {
                        sum.add(other.position);
                        count++;
                    }
                });

                if (count > 0) {
                    sum.divideScalar(count);
                    const steer = sum.sub(fish.position);
                    steer.normalize();
                    steer.multiplyScalar(0.01);
                    return steer;
                }

                return new THREE.Vector3();
            }

            attract(fish) {
                const steer = this.attractionPoint.clone().sub(fish.position);
                const d = steer.length();
                if (d > 0) {
                    steer.normalize();
                    steer.multiplyScalar(0.01 / Math.max(d * 0.1, 1));
                }
                return steer;
            }

            wander(fish) {
                fish.wanderAngle += (Math.random() - 0.5) * 0.1;
                const wander = new THREE.Vector3(
                    Math.cos(fish.wanderAngle) * 0.01,
                    Math.sin(fish.wanderAngle) * 0.01,
                    (Math.random() - 0.5) * 0.005
                );
                return wander;
            }

            keepInBounds(fish) {
                // Aquarium boundaries - change direction instead of bouncing
                const tankWidth = 15;   // X bounds
                const tankDepth = 10;   // Z bounds
                const buffer = 1; // Small buffer zone
                
                let hitBoundary = false;
                
                // X boundaries (left-right walls)
                if (fish.position.x > tankWidth - buffer) {
                    fish.position.x = tankWidth - buffer;
                    fish.swimming.forward.x = -Math.abs(fish.swimming.forward.x); // Force leftward
                    hitBoundary = true;
                }
                if (fish.position.x < -tankWidth + buffer) {
                    fish.position.x = -tankWidth + buffer;
                    fish.swimming.forward.x = Math.abs(fish.swimming.forward.x); // Force rightward  
                    hitBoundary = true;
                }
                
                // Z boundaries (front-back walls)
                if (fish.position.z > tankDepth - buffer) {
                    fish.position.z = tankDepth - buffer;
                    fish.swimming.forward.z = -Math.abs(fish.swimming.forward.z); // Force backward
                    hitBoundary = true;
                }
                if (fish.position.z < -tankDepth + buffer) {
                    fish.position.z = -tankDepth + buffer;
                    fish.swimming.forward.z = Math.abs(fish.swimming.forward.z); // Force forward
                    hitBoundary = true;
                }
                
                // Normalize direction vector after boundary adjustment
                if (hitBoundary) {
                    fish.swimming.forward.normalize();
                    // Don't set turning state for boundary hits - just redirect
                    console.log('Fish hit boundary, redirected');
                }
                
                // Keep fish at water surface level
                fish.position.y = 0;
            }

            updateFishScale(fish) {
                // Update fish size based on depth position - reduced to 3/4 size
                const baseSize = 1.0; // Reduced from 2.0
                const depthScale = 1.0 + (fish.position.z / 20.0);
                const finalScale = Math.max(0.2, Math.min(1.5, baseSize * depthScale)); // Max 1.5 instead of 5.0
                fish.mesh.scale.set(finalScale, finalScale, finalScale);
            }

            updatePerformance() {
                this.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    document.getElementById('fps').textContent = fps;
                    
                    // Memory usage (approximate)
                    const memory = Math.round(performance.memory ? 
                        performance.memory.usedJSHeapSize / 1024 / 1024 : 0);
                    document.getElementById('memory').textContent = memory;
                    
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const deltaTime = this.clock.getDelta();
                const currentTime = this.clock.getElapsedTime();

                // Gradual fish spawning - spawn one fish every 3-6 seconds
                if (this.spawnedFish < this.maxFish && currentTime - this.lastSpawnTime > (3 + Math.random() * 3)) {
                    const fish = this.createFish();
                    this.fishes.push(fish);
                    this.scene.add(fish.mesh);
                    this.spawnedFish++;
                    this.lastSpawnTime = currentTime;
                    
                    document.getElementById('fishCount').textContent = this.spawnedFish + '/' + this.maxFish;
                    console.log('Fish', this.spawnedFish, 'spawned at time:', currentTime.toFixed(1));
                }

                // Update each fish and their individual animations
                this.fishes.forEach(fish => {
                    // Update individual fish animation
                    if (fish.mixer) {
                        fish.mixer.update(deltaTime);
                    }
                    this.updateFish(fish, deltaTime);
                });

                // Render
                this.renderer.render(this.scene, this.camera);

                // Update performance monitor
                this.updatePerformance();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialize the app when page loads and Three.js is ready
        function initApp() {
            if (typeof THREE !== 'undefined' && THREE.GLTFLoader) {
                new OptimizedFishSwimming();
            } else {
                setTimeout(initApp, 100);
            }
        }
        
        window.addEventListener('load', initApp);

        // Clean up on unload
        window.addEventListener('beforeunload', () => {
            // Clean up Three.js resources
            if (window.fishApp && window.fishApp.renderer) {
                window.fishApp.renderer.dispose();
            }
        });
    </script>
</body>
</html>